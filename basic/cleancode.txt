'''
파이썬 클린코드

#1_ Docstring

0. 문서화
Docstring에 대해서 알아보기전에 문서화에 대해서 한번 짚어보자.
프로젝트를 진행해보거나, 다른 개발자와 함께 협업을 진행해본 개발자라면 '문서화'가 왜 필요한지 어느 정도 느꼈을 수 있다.
여러분들은 지금 개발하고 있는 프로젝트, 지금 작성한 코드를 한달, 일년뒤에 보았을 때 
코드를 작성할 때와 같이 부드럽게 코드 리딩이 가능한가? 
사실 한달, 일년도 아니다. 복잡한 로직과 다양한 처리를 진행하는 개발을 진행할 때면 
당장 내일에 그 코드를 정확히 기억하기 힘든 경우도 많을 것이다.
물론 그렇게 리딩이 어렵다는 것은 로직 자체가 깔끔하지 못하다는 문제이지 않을까란 생각을 할 수도 있을 수 있다. 
당연히 그 또한 중요하겠지만, 만약 내가 작성한 코드를 다른 동료 개발자가 본다면 어떠할까? 
로직이 깔끔하지만 수많은 함수와 클래스들의 코드를 직접 리딩해가며 모든 로직을 '코드'만으로 이해하고 받아들인다는건 
상상하는 것보다 매우 힘든 일이 될 수 있다.
하지만 만약 각각의 함수와 클래스, 기타 등등이 어떤 기능을 하는 것인지 알아볼 수 있도록 '문서화'를 해두었다면 어떨까? 
내가 작성한 코드를 매우 오랜만에 보더라도 해당 함수의 매개변수는 어떤 타입인지, 해당 함수가 어떤 기능을 하는 것인지, 
그리고 반환 값은 무엇인지 한번에 알아 볼 수 있어 해당 함수를 이용하거나 받아들이는데 매우 편리할 것이다. 
즉, 문서화를 통해서 구현된 코드에 대해 보다 명확하고 편리하게 설명할 수 있으며 특정 함수나 클래스 등을 
다른 곳에서 사용하고자 할 때 
그것들에 대해 손쉽고 명확하게 이해하고 사용할 수 있어 추가적인 개발에 있어 사전에 버그를 방지할 수 있을 것이다.
물론 위에서 이야기한 내용보다 '문서화'가 필요하고 중요한 이유는 더 다양하고 더 중요한 이유들이 있을 수 있지만 
이정도라면 개발자 누구나 '문서화'가 왜 필요한지 어느정도 스스로 생각해 볼 수 있는 계기가 될 것이라 생각한다.

1. Docstring 이란?
Docstring 은 쉽게 생각했을 때, 코드에 포함된 문서(Document)이다. 
즉, 코드에 대한 문서화를 코드 밖에 워드나 한글 파일, 엑셀을 이용해 따로 하는 것이 아니라 코드 내부에 문서화를 실시한다는 것이다.
특히나 파이썬과 같은 동적 타입의 언어이기 때문에 코드내부에 문서를 포함시키는 docstring 이 매우 좋다. 
파이썬에서는 파라미터의 타입을 체크하거나 강제하지 않는다. 헌데 특정 함수나 클래스를 이용하거나 수정하고자 할때 
그에 대한 설명이 명확하게 나와있다면 그러한 이용이나 수정이 매우 간편하게 진행될 것이다.
파이썬에서 docstring 은 함수나 클래스 모듈등에 정의할 수 있다. 
그리고 작성한 내용을 확인하기 위해서는 해당 객체의 __doc__ 라는 속성을 이용하면 된다. (더블언더바)
docstring 에 대한 사용법을 알아보기 이전에 실제로 docstring 이 정의된 예시를 확인해보자.
print(len.__doc__)
print(dict.__doc__)
위와 같이 dictionary 개체의 docstring 을 보니, 어떻게 사용하는지도 설명을 첨부하였다.
만약 우리가 dictionary 가 무엇인지 궁금했다면 이와 같이 docstring 을 통해서 간략하게나마 확인할 수 있을 것이다.

2. Docstring 사용하기
class DocstringClassExample():
    """
    DocstringClassExample() 예제 클래스
    class에 대한 설명을 함께 적어준다.
    """
 
    def docstring_func_example():
        """
        Return 0 always
        """
        print("ocstring_func_example 함수를 실행하였습니다.")
        return 0
 
def main():
    print("Docstring 만들어보기")
    new_doc = DocstringClassExample()
    print("Class docstring start")
    print(new_doc.__doc__)
    print("Class docstring end")
    print()
    print("Function docstring start")
    print(new_doc.docstring_func_example.__doc__)
    print("Function docstring end")
 
if __name__ == '__main__':
    main()

위와 같이 간단한 Class 하나와 함수하나를 만들었다.
docstring은 위와 같이 클래스나 함수 선언 바로 하단부에 따옴표 세개를 이용하면 된다.(쌍따옴표, 홀따옴표 무관하다.)
이렇게 만든 코드를 실행시켜보면 다음과 같이 결과가 출력된다.
Docstring 만들어보기
Class docstring start
        DocstringClassExample() 예제 클래스
        class에 대한 설명을 함께 적어준다.
Class docstring end
Function docstring start
                Return 0 always
Function docstring end

docstring 자체를 만들어내는 것, 이를 사용하는 것은 함께 알아본 것 처럼 전혀 어렵지 않고 너무 간단하다.
하지만 보다 중요한 것은 이러한 기능을 놓치지 않고 이용하면서 보다 유지보수 좋은 코드를 지속적으로 만들어 나가는 것, 
그리고 기존에 있던 docstring을 최신으로 유지하는 노력일 것이다.


#2_ Annotation

1. Annotation 이란?
우선 Annotation 의 사전적 정의는 "주석"이다. 즉, 쉽게 말해서 코드에 대한 추가적인 설명을 이야기하는 무언가를 의미한다.
대표적으로 Java언어에서 함수나 클래스 상단에 @를 통해 annotation 을 표시한다.
자바에서의 annotation과 파이썬에서의 annotation은 차이가 있을 수 있다. 
하지만 기본적으로 로직이 되는 코드를 "도와주는" 의미에서는 크게 다르지 않다고 볼 수 있다.
(사실 java의 annotation 과 같은 것을 파이썬에서는 decorator 로 나타내기 때문에 엄밀히 말했을 때, 
자바의 annotation 과 파이썬의 annotation 은 다르다고 볼 수 있다.)
사실 파이썬에서는 annotation에 대한 강제성이 전혀 없다. 우리가 파이썬에서 #을 이용하거나, 
지난 포스팅에서 알아본 docstring 과 같이 안써도 되지만, 보다 좋은 코드가 될 수 있도록 
추가적으로 관리해주는 것 중 하나일 뿐이다.
파이썬에서 사용하는 annotation 의 기본 아이디어는, 코드를 사용하는 이에게 함수나 클래스에 대해 
그 인자값의 형태 또는 반환값을 알려주자는 것이다.
함수에 대해서는 함수의 인자에 대한 타입에 대한 힌트를 적거나,
함수의 return 값에 대한 타입을 알려줄 수 있다. 또한 파이썬 3.6 이후로는 변수에 대해서도 직접 annotation을 달 수 있다. 
즉, 클래스에서 사용되는 변수값에 대해 그 타입을 적어둘 수 있다는 것이다.

2. Annotation 사용하기
#-*- coding:utf-8 -*-
class AnnotationClassExample:
    """
    Annotation에 대한 예시를 확인하기 위한 class입니다.
    __annotation__ 속성을 통해
    class할당되는 first_param과 second_param에 대한 타입을 확인할 수 있습니다.
    """
    first_param: str
    second_param: int
 
    def set_first_param(self, value: str) -> None:
        """
        AnnotationClassExample 클래스의
        first_param 값을 바인딩합니다.
        함수의 반환은 없습니다.
        """
        self.first_param = value
 
    def set_second_param(self, value: int) -> bool:
        """
        AnnotationClassExample 클래스의
        second_param 값을 바인딩합니다.
        함수의 반환은 True or False 입니다.
        """
        if type(value) == int:
            self.second_param = value
            return True
        else:
            self.second_param = 0
            return False
 
def main():
    print("Annotation 만들어보기")
    new_class = AnnotationClassExample()
    print("\n* AnnotationClassExample 클래스의 annotations")
    print(new_class.__annotations__)
    print("\n* set_first_param 함수의 annotations")
    print(new_class.set_first_param.__annotations__)
    print("\n* set_second_param 함수의 annotations")
    print(new_class.set_second_param.__annotations__)
 
if __name__ == '__main__':
    main()

위의 코드에서는 AnnotationClassExample 클래스와 그 내부에 2개의 변수를 가지고 있으며, 클래스 내부에 2가지 함수를 구현해두었다. 
함수의 인자에 대한 annotation 과 함수의 return 에 대한 annotation 이 적용되었다.
이를 통해 함수를 사용하고자 하는 이는 함수의 인자가 어떤 타입을 가져야하는지, 
그리고 함수를 통해 얻게되는 값의 타입은 무엇인지 보다 쉽게 알 수 있다.
또한 파이썬 3.6부터 변수에 대한 annotation 이 가능하다고 했는데, 클래스 내부의 변수에 대한 annotation 으로 사용할 수 있다. 
이렇게 annotation 을 적용하면, 그 개체에 대해 __annotations__ 이라는 속성이 생긴다. 
그리고 해당 속성을 통해 우리가 적용해둔 annotation 값을 볼 수 있는 것이다.
실제로 위의 코드를 실행시켜 보면 main 함수내에서 각 클래스와 함수에 대해 __annotations__ 속성을 호출하고, 그 결과는 다음과 같다.

Annotation 만들어보기
* AnnotationClassExample 클래스의 annotations
{'first_param': <class 'str'>, 'second_param': <class 'int'>}
* set_first_param 함수의 annotations
{'value': <class 'str'>, 'return': None}
* set_second_param 함수의 annotations
{'value': <class 'int'>, 'return': <class 'bool'>}

우리가 코드에서 적용시켜준 annotation 들이 출력되는 것을 확인할 수 있다.
위와 같이 annotation을 통해 함수나 변수 등에 미리 타입에 대한 힌트를 적어둘 수 있다.
물론 이 또한 파이썬에서 강제성이 있거나, 지켜야 한다는 것은 아니다. annotation 은 말 그대로 '힌트'를 주는 것에 불과하다.


#3_ 개발 지침 약어

1. DRY / OAOO
DRY(Do not Repeat Yourself)와 OAOO(Once And Only Once)는 강조하고자 하는 의미가 비슷하므로 함께 다루어보자. 
두개의 약어는, '중복을 피하라'라는 의미를 가지고 있다.
즉, 특정 기능과 역할을 하는 것은 코드에 단 한 곳에 정의되어 있어야 하고 중복되지 않아야 한다. 
그리고 이를 통해 코드를 변경하고자 할 때 수정이 필요한 곳은 단 한 군데만 존재해야 한다.
코드의 중복이 발생한다는 건 유지보수를 하는데에 있어서 직접적인 영향을 미칠 수 있다는 것이다. 
다양한 문제가 있을 수 있지만 축약해보면 다음과 같은 3가지 문제가 대표적이다.

- 오류가 발생하기 쉽다.
특정 계산 로직이 코드 전체 여러 곳에 분포되어 있을 때, 계산 로직에 대한 변경사항이 발생하면 코드의 모든 곳을 찾아 
변경해주어야 하는데 이때 하나라도 빠뜨리면 오류가 발생하기 쉬워진다.
- 비용이 발생한다.
동일한 기능에 대한 반복 수정이 이루어져야 하기 때문에, 당연히 1회의 수정보다 다수의 수정에 있어서 비용적으로 손해가 발생한다.
- 신뢰성이 떨어진다.
동일한 기능이 코드 여러 곳에 분포되어 있을 때, 모든 곳을 찾아서 수정해야 한다. 물론 언어적 기능과 도구의 도움을 받을 수도 있지만, 
모든 곳을 정확히 기억하지 못할 수 있다는 점 때문에 시스템 전체의 신뢰성이 보다 떨어질 수 있다.
간단하게 나마 코드의 중복이 발생할 수 있는 예시와 적절히 조치 된 예시를 살펴보자.

#-*- coding:utf-8 -*-
# DRY / OAOO
 
user_math_score_dic = {
    'A': 90,
    'B': 93,
    'C': 30,
    'D': 100,
    'E': 31,
    'F': 82,
    'G': 79,
}
 
user_eng_score_dic = {
    'A': 30,
    'B': 63,
    'C': 39,
    'D': 94,
    'E': 10,
    'F': 49,
    'G': 68,
}
 
# Danger code
def get_user_score_list(user_math_score_dic, user_eng_score_dic):
    """
    input: 유저의 이름을 key로, 점수를 value로 가지는 dict형 자료형 2개
    output: 종합 점수 계산에 따라 내림차순으로 정렬한 유저의 이름 list
    """
    
    user_sum_score_dic = {}
    # 종합 점수 계산 (math*2 + eng)
    for k, math_score in user_math_score_dic.items():
        sum_score = math_score*2
        sum_score += user_eng_score_dic[k]
        user_sum_score_dic[k] = sum_score
 
    # 종합 점수에 따라 내림차순 정렬
    sorted_user = sorted(user_sum_score_dic.keys(), key=lambda x: user_sum_score_dic[x])
    return sorted_user
 
print("# Danger code")
print(get_user_score_list(user_math_score_dic, user_eng_score_dic))
 
 
# Good code
def calc_user_sum_score(user_math_score_dic, user_eng_score_dic):
    """
    input: 유저의 이름을 key로, 점수를 value로 가지는 dict형 자료형 2개
    output: 종합 점수 계산이 된 dict 자료형
    """
    user_sum_score_dic = {}
    # 종합 점수 계산 (math*2 + eng)
    for k, math_score in user_math_score_dic.items():
        sum_score = math_score*2
        sum_score += user_eng_score_dic[k]
        user_sum_score_dic[k] = sum_score
    return user_sum_score_dic
 
def get_user_score_list2(user_math_score_dic, user_eng_score_dic):
    """
    input: 유저의 이름을 key로, 점수를 value로 가지는 dict형 자료형 2개
    output: 종합 점수 계산에 따라 내림차순으로 정렬한 유저의 이름 list
    """
    user_sum_score_dic = calc_user_sum_score(user_math_score_dic, user_eng_score_dic)
 
    # 종합 점수에 따라 내림차순 정렬
    sorted_user = sorted(user_sum_score_dic.keys(), key=lambda x: user_sum_score_dic[x])
    return sorted_user
 
print("# Good code")
print(get_user_score_list(user_math_score_dic, user_eng_score_dic))

위의 코드를 보면 기존에 정의된 get_user_score_list 함수에서는 내부적으로 종합 점수에 대한 계산이 진행되고 있다.
만약 그러한 계산 로직이 다른 곳에서도 필요하면 어떻게 될까? 따로 함수화가 되어 있지 않기 때문에 동일 로직을 중복시켜야 한다. 
하지만 아래와 같이 calc_user_sum_score 라는 함수를 분리해두면, 추후 동일 로직이 필요할 때 해당 함수를 이용할 수 있을 것이다.

2. YAGNI / KIS
YAGNI(You Aren't Gonna Need It)와 KIS(Keep It Simple) 또한 의미하는 바가 비슷하므로 함께 다루도록 하자. 
두 약어가 의미하는 것은 '현재 주어진 문제에 적합한, 간단한 코드를 작성하라'이다.
YAGNI에서 보다 강조하는 것은, 과잉된 프로그래밍을 하지 말라는 것이다. 
우리는 결론적으로 시스템에 대한 확장성과 유지보수 등을 위해 보다 좋은 코드를 작성하려고 한다. 
하지만 그 목표가 코드를 작성하는 시점에 특정 미래적 상황을 예측해야 한다는 것은 아니다. 
필자가 참고하고 있는 서적에서는 이렇게 이야기 한다.
유지보수가 가능한 소프트웨어를 만드는 것은 미래의 요구 사항을 예측하는 것이 아니다 - 파이썬 클린 코드
우리가 확장성과 유지보수 등을 위한 소프트웨어를 만들어야 한다는 것은, 다가오지 않은 미래에 대해 
특정 상황을 예측해야 한다는 것은 아니다. 오히려 그랬다면 코드적인 학습보다, 미래학자와 같은 학습을 해야하지 않을까 싶다. 
따라서, 프로그래밍 시점에서는 현재의 요구사항을 잘 해결하기 위한 소프트웨어를 작성하되, 이때에 보다 수정가능하고, 
높은 응집도와 낮은 결합력을 가지는 프로그래밍을 해야한다. 미래에 ~이 필요할거야, 나중에 ~가 고려되지 않을까, 라는 생각에 
현재의 요구사항을 넘어서는, 과잉 프로그래밍을 하면 안된다.
KIS에서 조금 더 강조하는 점은 현재에 선택한 솔루션이 최선의, 최소한의 솔루션이어야 한다는 것이다. 
문제를 해결하는데에 있어서 화려하고 어려운 기술은 필수요소가 아니다. 
항상 보다 간결하고 최소한의 솔루션으로 문제를 해결해야 한다.
단순하게 해결될 수 있는 문제를 보다 복잡하게 해결하게 되면 추후 해당하는 함수, 클래스, 데이터에 대한 수정에 있어 
더 큰 어려움이 내포될 수 있다.
더군다나, 파이썬의 철학에서는 '단순한 것이 복잡한 것보다 낫다.' 라고 이야기 하고 있다.

3. EAFP / LBYL
EAFP(Easier to Ask Forgiveness than Permission)와 LBYL(Look Before You Leap)는 상대적인 의미를 지니고 있는 약어이다.
우선 EAFP는 허락보다 용서를 구하는 것이 쉽다는 말인데 이 의미는 일단 코드가 실행되도록 두고 동작하지 않을 경우를 
대응한다는 의미이다. 일반적으로는 코드가 실행되도로 하고 발생할 수 있는 에러에 대해서 catch, except문을 이용해 
조치하는 코드를 의미한다.
이에 반해 LBYL은 도약하기 전에 살피라는 말이며, 의미적으로는 코드가 실행되기 이전에 확인/검토를 하라는 의미이다. 
간단하게는 if 문 등을 이용한 체크 정도로 생각하면 된다.
아래 코드는 파일을 사용하기 이전에 LBYL에 따른 코드와, EAFP에 따른 코드를 나타내고 있다.

# LBYL
if os.path.exists(filename):
    with open(filename) as f:
        ...

# EAFP
try:
    with open(filename) as f:
        ...
        
except FileNotFoundError as e:
    logger.error(e)
    ...


#4_ 상속과 컴포지션

1. 상속(Inheritance)
상속이란 기본적으로 자신이 가진 속성과 메소드를 물려주는 클래스(부모클래스, Parent class, Super class)와 
이를 물려받는 클래스(자식클래스, Child class, Sub class)로 이루어진다.
객체 지향적 소프트웨어를 디자인하고 구현할 때 상속은 중요한 개념으로, 또 자주 사용된다. 
하지만 상속개념을 활용하면 부모클래스와 자식클래스간에 강력한 결합력(Coupling)이 발생하게 된다.
좋은 코드, 유지보수를 위한 코드를 생각할 때 결합력을 낮추고, 응집도는 높여야 한다고 했는데, 
이러한 점을 고려하면 상속이 무조건적으로 좋은 방안은 아닐 수 있다.
즉, 상속이란 것이 좋은 경우와 그렇지 않은 경우를 잘 선별해가며 활용할 수 있어야한다.
만약 새로운 자식클래스를 만들었을 때 해당 자식클래스가 올바르게 정의된 클래스인지 확인하기 위해서는 
상속받은 모든 메서드를 실제로 자식클래스에서 사용하는지를 살펴보아야 한다. 
만약 대부분의 메소드를 실제로 필요로 하지 않는다면 다음과 같은 이유로 설계상의 실수일 수 있다.
- 부모클래스가 잘 정의된 인터페이스 대신 막연한 정의와 너무 많은 책임을 가진 경우
- 자식클래스가 확장하려고 하는 부모클래스의 적절한 세분화가 아닌경우
따라서, 상속을 쓰는 올바른 경우는 새로 정의하고자 하는 자식클래스가 부모클래스의 기능을 그대로 물려받으면서 
이중 특정 기능을 수정하고자 하거나, 추가적인 기능을 구현하고자 할 때이다.
또한 상속에서도, 인터페이스 정의는 또 다른 상속의 올바른 경우로 생각할 수 있다. 
어떤 객체에 인터페이스 방식을 강제하고자 할 때, 실제 기능을 구현하지 않은 추상클래스를 만들고, 
이를 상속받는 자식클래스에서 실제로 기능을 구현하게 한다. 
그럼 올바르지 않은 상속의 경우는 어떠한 케이스가 있을까? 바로 예시 코드를 살펴보자.

import collections
from datetime import datetime
 
class TransactionalPolicy(collections.UserDict):
    """잘못된 상속의 예시"""
    
    def change_in_policy(self, customer_id, **new_policy_data):
        self[customer_id].update(**new_policy_data) 
 
policy = TransactionalPolicy({
    "client001":{
        "fee": 1000.0,
        "expiration_date": datetime(2020,1,3),
    }
})
 
policy["client001"]
# {'fee': 1000.0, 'expiration_date': datetime.datetime(2020, 1, 3, 0, 0)}
 
policy.change_in_policy("client001",expiration_date=datetime(2020,1,4))
policy["client001"]
# {'fee': 1000.0, 'expiration_date': datetime.datetime(2020, 1, 4, 0, 0)}
 
위의 코드를 살펴보면 TransactionalPolicy 클래스는 파이썬 내장 collections 의 사전자료형을 상속받아 구현하였다. 
그리고 TransactionalPolicy 클래스에서 사용하고자 하는 change_in_policy 함수를 구현하였다.
이후 policy 라는 TransactionalPolicy 객체를 만들어 추가한 함수를 사용하였다. 
이처럼 원하는 기능을 수행하는 클래스를 구현하였지만, 과연 이 클래스가 사전자료형을 상속하는 것이 올바른 것일까? 
파이썬에서 객체가 사용가능한 메서드를 출력해주는 dir 함수를 이용하여 policy 객체가 이용가능한 메서드를 살펴보자.

dir(policy)
# ['_MutableMapping__marker', '__abstractmethods__', '__class__', '__contains__', '__copy__', '__delattr__',
# '__delitem__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__',
# '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__module__',
# '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__setattr__', '__setitem__',
# '__sizeof__', '__slots__', '__str__', '__subclasshook__', '__weakref__', '_abc_impl',
# 'change_in_policy', 'clear', 'copy', 'data', 'fromkeys', 'get', 'items',
# 'keys', 'pop', 'popitem', 'setdefault', 'update', 'values']

policy 객체를 보면 우리가 추가로 구현한 change_in_policy 라는 함수 이외에도 다양한 함수가 있다. 
정말 해당 객체에서 pop, popitem 등의 함수가 필요로 한 것일까? 필요하지 않을텐데 포함되어 있다. 
더군다나 해당 함수들은 public 메서드이기 때문에 이를 사용하게 될 가능성도 있다. 
이러한 것을 살펴보아, TransactionalPolicy 클래스가 사전자료형을 상속받은 것은 올바르지 않다고 볼 수 있다.
더군다나, 의미적으로 보았을 때 부모클래스로부터 상속을 받은 자식클래스는 개념적으로 확장되거나, 
세부적이라는 것을 의미해야 한다. 하지만 TransactionalPolicy 클래스가 사전자료형에 대해서 개념적으로 확장되거나 
세부적이라는 것이라고 생각할 수 있을까?
그럼, 우리는 TransactionalPolicy 클래스를 정의하기 위해서 어떻게 해야할까?
이러한 경우 컴포지션이라는 개념을 활용해볼 수 있다.

2. 컴포지션(Composition)
컴포지션이란, 상속과 다르게 단순히 사용한다는 개념이다. 즉, 기존의 상속 개념에서의 자식클래스가 부모클래스의 모든 속성을 물려받는게 아니라, 
자식클래스가 필요한 속성만 부모클래스로부터 가져와 사용하는 것이다.
일반적으로 상속은 암시적 선언이라고 하며, 컴포지션은 명시적 선언이라고 한다.

class NewTransactionalPolicy:
    """컴포지션을 활용한 예시"""
    
    def __init__(self, policy_data, **extra_data):
        self._data = {**policy_data, **extra_data}
    
    def change_in_policy(self, customer_id, **new_policy_data):
        self._data[customer_id].update(**new_policy_data)
        
    def __getitem__(self, customer_id):
        return self._data[customer_id]
    
    def __len__(self):
        return len(self._data)
 
new_policy = NewTransactionalPolicy({
    "client001":{
        "fee": 1000.0,
        "expiration_date": datetime(2020,1,3),
    }
})
 
new_policy["client001"]
# {'fee': 1000.0, 'expiration_date': datetime.datetime(2020, 1, 3, 0, 0)}
 
new_policy.change_in_policy("client001",expiration_date=datetime(2020,1,4))
new_policy["client001"]
# {'fee': 1000.0, 'expiration_date': datetime.datetime(2020, 1, 4, 0, 0)}

이전의 예시와 달리 NewTransactionalPolicy 클래스에서는 사전자료형을 상속받지 않았다.
하지만 __init__함수에서 _data를 private로 선언하면서 사전자료형의 데이터로 초기화한다. 
그리고 이후 우리가 사용하고자 하는 change_in_policy함수와 __getitem__함수에서 _data, 
즉 사전 자료형을 활용하여 구현하고자 하는 기능을 구현하였다.
이렇게 직접 사전자료형을 상속받지 않고, 단순히 사전자료형을 가져와서 사용하였다.
이를 통해 추후 사전자료형에서 변경이 발생하더라도 그 인터페이스만 잘 유지된다면 NewTransactionalPolicy에서는 별도의 변경이 필요없다. 
더군다나 이전에 dir함수를 통해 policy 객체가 사용가능한 메서드를 살펴본 것 처럼 new_policy 객체를 살펴보면 다음과 같다.

dir(new_policy)
# ['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__',
#  '__getattribute__', '__getitem__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__',
#  '__len__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__',
#  '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__',
#  '_data', 'change_in_policy']

확실히 상속을 받았던 policy 객체에 비해, 사용 가능하지만 필요하지 않았던 함수가 사라진 것을 확인할 수 있다.
이렇게 상속과 컴포지션은 단순히 별개의 것이 아니라, 기존의 클래스를 재사용하는 상황에 있어서, 
상속을 사용해야 할지 컴포지션을 사용해야 할 지 신중히 판단해야 한다. 
단순히 현상황만을 고려한다기 보다는 상속과 컴포지션의 특성과, 장단점을 잘 생각하고 활용해야 
새롭게 정의하는 클래스가 추후 가져올 문제를 최소화 할 수 있다.


#5_ 인자(Argument)

0. 인자(Argument)와 매개변수(Parameter)
본격적으로 인자에 대해서 알아보기전에, 자주 헷갈릴 수 있는 인자와 매개변수에 대해서 잠깐 짚고 넘어가도록 하자. 
물론 이는 파이썬언어 뿐만이 아니라 다른 언어에서도 혼동되서 사용될 수 있는 개념이다.

def func1(param1, param2):
    print(f"param1:{param1}, param2:{param2}")
 
func1("AA","B")
# param1:AA, param2:B

위의 코드를 살펴보며 이야기해보자.
함수 func1에는 param1과 param2가 전달되도록 정의되어있다. 이렇게 함수가 정의되는 내용에 포함되는 특성을 매개변수(Parameter)라고 한다. 
즉, 함수 func1는 2개의 매개변수, param1과 param2를 전달받아서 이를 출력하는 기능을 하는 것이다.
그리고 4번 라인에서는 func1에 "AA"라는 값과 "B"라는 값을 전달하며 함수를 호출하고 있다. 
이때 함수에 전달하는 값을 인자(Argument)라고 한다.
이러한 차이에 의해서 매개변수(Parameter)는 변수(Variable)로 보아야 하며, 인자(Argument)는 값(Value)로 보아야한다. 
두 개념이 비슷하다고 생각할 수 있으나, 함수에 대해서 이야기를 할때에는 구분해서 사용해야 혼동되지 않을 수 있다.

1. 파이썬에서 인자의 전달방식
앞에서 인자에 대해서 설명할 때, 함수를 호출하며 값으로 전달되는 것이라고 설명했다. 
하지만 사실 함수에 '값(Value)'로 전달되는 것은 특정 상황에서만이다.
함수에 인자가 전달될 때에는, 실제로 그 값이 넘어가는 "값에 의한 호출(Call by Value)"와 
값이 참조하고 있는 참조값이 넘어가는 "참조에 의한 호출(Call by Reference)" 두가지가 존재한다.
(만약 당신이 C언어를 했다면 포인터를 공부하면서 이 개념을 접했을 수도 있다.)
각각의 호출방법이 어떤 차이가 있는지 먼저 코드로 살펴보자.

def call_by_value(param1:int)->None:
    param1 += 1
    print(f"call by value: {param1}")
    
def call_by_ref(param2:list)->None:
    param2[0] += 1
    print(f"call by ref: {param2}")
    
val1 = 3
val2 = [3]
 
print(f"before val1:{val1}")
call_by_value(val1)
print(f"after val1:{val1}")
print(f"before val2:{val2}")
call_by_ref(val2)
print(f"after val2:{val2}")
# before val1:3
# call by value: 4
# after val1:3
# before val2:[3]
# call by ref: [4]
# after val2:[4]

위의 코드에서는 call_by_value 함수와 call_by_ref함수를 정의하여 사용하고 있다. 
각각의 함수가 받는 매개변수의 타입은 다르지만, 그 이유에 대해서는 뒤에서 이야기하겠다. 
우선 "값에 의한 호출"과 "참조에 의한 호출"에 대한 차이를 이해해보자.
우리가 주목해야 할 것은 19번줄부터 25번줄까지의 결과이다. 
val1과 val2 모두 함수를 거치기 이전에 출력을 한 다음, 함수 호출시 함수 내부에서 출력한 후에, 함수 호출이 끝난 후에 출력을 한다.
먼저 val1의 값을 보면, 함수 호출 이전에 3이란 값을 출력하고, 함수 내부에서 출력될 때에는 1을 더한 4가 출력되고 있다. 
그리고 함수가 끝난 다음에는 값이 변화하지 않고 그대로 3을 출력한다. 즉, 함수에서 더한 1이 val1에 영향을 미치지 않았다.
그럼 이번에는 val2의 값을 살펴보자. 당연히 함수 호출 이전에는 3을 출력했다. 그리고 함수 내부에서 출력될 때에는 1을 더한 4가 출력되었다. 
여기까지는 val1과 같았지만, 함수 호출이 끝난 뒤 val2를 출력했을 때에는, 
val1과 달리 기존의 val2=3값에서 변화가 되어 4를 출력하였음을 볼 수 있다.
즉, val1은 함수에서 내부적으로 1을 더했지만, 기존의 값에 영향을 미치지 않았고, val2는 함수에서 더한 1이 실제 값이 영향을 미쳤다.
이것이 바로 "값에 의한 호출"과 "참조에 의한 호출"에 대한 차이로 발생한 것이다.
값에 의한 호출을 할 때에는, 함수로 인자가 전달될 때 동일한 "값"을 가진 객체를 복사하여 함수에 전달한다. 
즉, 위의 코드에서 val1이 call_by_value함수에 전달될 때에는 사실 val1자체가 전달된 것이 아니고, 
val1이 가진 값을 동일하게 가진 또다른 객체가 함수로 전달된 것이다. 
그리고 함수에서 1을 더한것은 val1이 아니고 val1과 똑같은 값을 가진 "val1과 다른 객체"에 더한 것이다. 
이로 인해 함수에서 전달받은 값에 대해 변화를 시도해도 기존의 val1값은 변화가 없는 것이다.
이와 달리, 참조에 의한 호출을 할 때에는, 함수로 인자가 전달될 때 실제로 인자가 가진 "참조 값"을 전달한다. 
참조 값을 전달한다는 것은 실제로 인자 객체를 그대로 전달한다고 생각해도 된다. 
즉, 값에 의한 호출에서와 달리 인자를 복사한 객체를 전달하는 것이 아니라, 말 그대로 인자 그 자체를 전달하는 것이다. 
따라서 함수내부에서 전달받은 인자에 대해 변화를 주면, 실제로 그 인자에 영향이 있게 된다.
이것이 "값에 의한 호출"과 "참조에 의한 호출"의 차이이다.
C언어의 경우에는 인자를 값에 의한 호출로 전달할 것인지, 참조에 의한 호출로 전달할 것인지를 명시적으로 정해줄 수 있다. 
하지만 파이썬 같은 경우는 이를 명시적으로 나타내지 않는다.
그럼 파이썬에서는 "값에 의한 호출"과 "참조에 의한 호출"을 어떻게 구분할 수 있을까?
위의 코드를 통해 짐작했을 수도 있다. 파이썬에서는 따로 호출에 대한 명시적인 구분을 두지 않고, 
함수에 전달되는 인자의 타입(type)에 의해서 결정된다.
변수 타입에는 불변형(immutable) 객체와, 가변형(mutable) 객체가 있다. 
즉 값의 수정이 허용되지 않는 변수 타입이 있으며, 값의 수정이 허용되는 변수 타입이 있다.
이를 통해, 함수에 전달되는 인자가 불변형 객체, 값의 수정이 허용되지 않는 변수타입이라면 이는 "값에 의한 호출"로 함수에 전달된다. 
하지만 함수에 전달되는 인자가 가변형 객체, 값의 수정이 허용되는 변수타입이라면 이는 "참조에 의한 호출"로 함수에 전달된다.
때문에 이를 파이썬 공식 문서에서는 call by value나 call by reference라는 설명이 아닌, call by assignment라고 설명하고 있다. 
함수에 할당되는 변수의 타입에 따라서 그 방식이 달라지기 때문이다.
파이썬에서 불변형객체, 가변형객체는 아래와 같이 나뉜다.
* 불변형(immutable) 객체 : int, float, str, tuples 등
* 가변형(mutable) 객체 : list, set, dict 등

2. 가변 인자
파이썬에서는 다른 언어와 같이, 가변인자 함수를 지원한다. 가변인자 함수라 함은 인자의 개수가 정해지지 않은 함수라고 생각하면 된다.

def args_test_func1(a, b, c):
    print("* call args_test_func1")
    print(f"a:{a}, b:{b}, c:{c}, a+b+c:{a+b+c}")
    print("* END args_test_func1", end='\n\n')
    
def args_test_func2(a, b, *args):
    print("* call args_test_func2")
    print(f"a:{a}, b:{b}, args:{args}, a+b+c:{a+b+sum(args)}")
    print("* END args_test_func2", end='\n\n')
    
args_test_func1(1,2,3)
args_test_func2(1,2,3)
args_test_func2(1,2,3,4,5,6)
# * call args_test_func1
# a:1, b:2, c:3, a+b+c:6
# * END args_test_func1
# * call args_test_func2
# a:1, b:2, args:(3,), a+b+c:6
# * END args_test_func2
# * call args_test_func2
# a:1, b:2, args:(3, 4, 5, 6), a+b+c:21
# * END args_test_func2

위의 코드에서 2개의 함수를 정의했다. args_test_func1 함수는 우리가 기존에 보던 함수처럼 a,b,c 3개의 매개변수를 정의한 함수이다. 
아래 결과에서도 3개의 인자를 전달해 함수가 올바르게 기능했다.
이와 달리 args_test_func2 함수에서는 a,b라는 매개변수와 함께, *args 라는 매개변수를 정의하였다. 
이렇게 *를 이용한 매개변수는 가변인자를 받을 수 있는 것으로 해석된다. 
즉, 개수가 정해지지 않은 인자를 args라는 이름으로 받아서 처리하겠다는 것이다.
실제로 3개 이상의 인자를 함수에 전달했는데, 3부터 6까지는 args라는 이름으로 받아서 처리한 것을 볼 수 있다. 
약간의 차이점은 args로 받은 인자는 튜플로 받아서 처리했다는 점이다.
이렇게 *를 사용하는 것을 패킹(packing)한다고 말하기도 하는데, 다음의 코드를 보면 그 의미가 더 와닿을 것이다.

def packing_func1(a, b, c):
    print(f"a:{a}, b:{b}, c:{c}, a+b+c:{a+b+c}")
    
packing_list = [1,2,3]
packing_func1(packing_list)
# ---------------------------------------------------------------------------
# TypeError                                 Traceback (most recent call last)
# <ipython-input-15-aaa44dbee827> in <module>
#       3 
#       4 packing_list = [1,2,3]
# ----> 5 packing_func1(packing_list)
# TypeError: packing_func1() missing 2 required positional arguments: 'b' and 'c'
 
packing_func1(*packing_list)
# a:1, b:2, c:3, a+b+c:6

packing_func1은 이전와 같이 3개의 매개변수를 정의한 함수이다. 그리고 이 함수를 호출하기 위해 3개의 int값을 가지는 리스트, 
packing_list를 정의했다. 그리고 해당 리스트를 그대로 인자로 전달하면 에러가 발생한다. 
타입의 맞고 틀림을 떠나서, packing_func1에서는 3개의 인자가 필요한데, 1개의 인자만 전달했기 때문이다.
이를 해결하기 위해서는 파이썬의 *를 이용한 패킹 기법을 사용하면 된다. 
즉, packing_list를 *를 통해 패킹함으로써 3개의 인자에 대응하는 값을 전달할 수 있다.

3. 가변 키워드 인자
가변 키워드 인자는 위에서 알아본 가변 인자와 비슷하다. 가변인자에서는 별표( * )를 하나 사용했지만, 
가변 키워드 인자에서는 별표( * )를 2개 사용한다.

def kwargs_test_func1(**kwagrs):
    print(f"kwagrs:{kwagrs}")
    
kwargs_test_func1(key="value", test="wow")
# kwagrs:{'key': 'value', 'test': 'wow'}

가변 키워드 인자가 가변 인자 개념과 다른 점은, **kwagrs로 정의된 매개변수는 인자로 받은 값을 "딕셔너리"형태로 패킹한다는 것이다.
따라서 **가 붙은 매개변수는 딕셔너리형태로 함수 내에서 활용할 수 있다.
또한 가변 인자에서와 같이, 기존의 딕셔너리 자료형을 함수에 전달할 때, 다음과 같이 사용할 수 있다.

def kwargs_test_func2(a, b, c):
    print(f"a:{a}, b:{b}, c:{c}, a+b+c:{a+b+c}")
    
kwagrs_dict = {
    'a': 1, 'b': 2, 'c': 3
}
 
kwargs_test_func2(**kwagrs_dict)
# a:1, b:2, c:3, a+b+c:6


#6_ SOLID, 단일 책임 원칙(SRP)

0. SOLID란?
우선 솔리드, SOLID는 객체 지향 프로그래밍 및 설계의 다섯가지 기본 원칙을 이야기한다. 
프로그램이 시간이 지나도 유지 보수 및 확장이 쉬울 수 있도록 하기 위한 원칙이며, 우리가 학습하고자 했던 클린코드를 위한 원칙이기도 하다. 
조금 더 구체적으로, SOLID는 아래와 같은 5가지 원칙을 이야기 한다.

1. Single Responsibility Principle(단일 책임 원칙)
2. Open/Closed Principle(개방/폐쇄 원칙)
3. Liskov Substitution Principle(리스코프 치환 원칙)
4. Interface Segregation Principle(인터페이스 분리 원칙)
5. Dependency Inversion Principle(의존관계 역전 원칙)

1. SRP(Single Responsibility Principle)
단일 책임 원칙(SRP)이란 하나의 클래스는 하나의 책임만 가지며, 그 책임에 대해 완전히 캡슐화 해야 함을 말한다. 
클래스가 하나의 책임만 가진다는 것은, 하나의 클래스는 하나의 일을 담당하고 있으며, 
클래스를 변경해야 할 이유는 오직 한가지가 존재한다는 것으로 생각할 수 있다. 이러한 원칙은, 코드의 응집력을 높이는데 도움을 준다. 
간혹 하나의 클래스가 다양한 책임을 지고 있는 경우가 있는데, 이러한 클래스(객체)를 일컬어 신(god) 객체라고 이야기 한다. 
이러한 신 객체가 존재하면 시스템에 대한 유지보수가 어려워진다.
어떤 면에서 단일 책임 원칙은, 관계형 데이터베이스 설계에서의 정규화 개념과 유사하다고 생각할 수 있다. 
만약 객체의 속성이나 메서드 중에서 서로 특성이 다른 요소(그룹)가 발견되면 그러한 것들을 적절히 분리시켜야 한다.
이제 실제로 코드를 통해 너무 많은 책임을 가진 클래스와, 이를 단일 책임 원칙에 따라 분리한 예제를 살펴보도록 하자.

class Course:
    """너무 많은 책임을 가진 Course 클래스"""
    
    def __init__(self, code, name, schedule, pf):
        self.code = code
        self.name = name
        self.schedule = schedule
        self.pf = pf
    
    def connect(self, con)->bool:
        """DB connecting"""
        pass
    
    def close(self)->bool:
        """DB close"""
        pass
    
    def get_course_by_pf(self, professor)->list:
        """professor로 강의 찾기 함수"""
        pass
    
    def save_course(self, Course)->bool:
        """DB에 course 저장하기"""
        pass
    
    def update_course(self, code)->bool:
        """특정 code를 가진 course를 DB update 하기"""
        pass


먼저 위의 Course 클래스를 살펴보자.
해당 Course 클래스는 너무 많은 책임을 가지고 있다. 클래스의 생성자 __init__함수가 정의되어 있으면서 DB접근과 관련된 함수들도 함께 정의되어 있다.
즉, Course 객체의 속성들에 대한 관리를 하고 있으면서, Course의 DB 내용에 대한 관리도 하고 있다. 이러한 경우 DB에 대한 시스템 변경이 있을 때나, 
Course의 속성에 대한 변경이 있을 때 동일한 클래스를 수정하고 서로 영향이 없도록 신경써야 한다.
따라서 위와 같은 클래스는 아래와 같이 분리할 수 있다.

class Course:
    """SRP원칙을 준수한 Course 클래스"""
    
    def __init__(self, code, name, schedule, pf):
        self.code = code
        self.name = name
        self.schedule = schedule
        self.pf = pf
 
class CourseDB:
    """SRP원칙을 준수한 CourseDB 클래스"""
    def __init__(self, con):
        self.con = con
    
    def connect(self)->bool:
        """DB connecting"""
        pass
    
    def close(self)->bool:
        """DB closing"""
        pass
    
    def get_course_by_pf(self, professor)->list:
        """professor로 강의 찾기 함수"""
        pass
    
    def save_course(self, Course)->bool:
        """DB에 course 저장하기"""
        pass
    
    def update_course(self, code)->bool:
        """특정 code를 가진 course를 DB update 하기"""
        pass

이전과 달리 Course 클래스와 CourseDB 클래스로 나누어, DB를 관리하는 클래스를 따로 분리하였다. 
이렇게 됨으로써 각 클래스가 자신이 담당한 하나의 일에 대해서만 책임을 지게 된다.

이번에는 다른 예제를 살펴보자.

class Human:
    """추상화 과정이 필요한 Human 클래스"""
    def __init__(self, name, sex):
        self.name = name
        self.sex = sex
        
    def go_restroom(self):
        """화장실 가는 함수"""
        if(self.sex == '남자'):
            print("남자화장실로 간다.")
        elif(self.sex == '여자'):
            print("여자화장실로 간다.")
        else:
            print("성별을 지정해주세요.")

위의 Human 클래스에서는 객체 생성시에 성별을 정의하게 되어있다. 그리고 go_restroom에서는 성별에 따라 분기처리하여 로직을 처리한다. 
즉, Human클래스는 성별이 다른 두가지 케이스에 대한 책임을 동시에 가지고 있다. 

from abc import *
 
class HumanBase(metaclass=ABCMeta):
    def __init__(self, name):
        self.name = name
    
    @abstractmethod
    def go_restroom(self):
        pass
    
class Male(HumanBase):
    def __init__(self, name):
        super().__init__(name)
        self.sex = "남자"
    
    def go_restroom(self):
        print("남자화장실로 간다.")
        
class Female(HumanBase):
    def __init__(self, name):
        super().__init__(name)
        self.sex = "여자"
        
    def go_restroom(self):
        print("여자화장실로 간다.")

위와 같이 추상클래스, HumanBase 클래스를 만들어 주었다. 기본적으로 생성시에는 이름만 받고 
이를 상속받은 클래스들은 go_restroom을 구현하게끔 하였다.
그리고 HumanBase를 상속받는 Male 클래스와 Female 클래스를 정의함으로써, 성별이 다른 경우에 대해 각 클래스가 유일한 책임을 가지도록 하였다.
이렇게 우리가 SOLID에서 단일 책임 원칙에 대해 알아보면서 대표적인 두가지 예제를 살펴보았다.
첫번째, Course 클래스에서는 단일 클래스에서 너무 많은 액션, 업무를 담당하고 있어 이를 분리함으로써 단일 클래스가 하나의 책임만 가지도록 하였다.
두번째, Human 클래스에서는 보다 높은 추상과 과정을 통해서 각 클래스가 하나의 책임만 가지도록 설정하였다.
이렇게 단일 책임 원칙을 지킨 경우에 클래스에 대한 외부 영향도를 최소화 할 수 있으며, 결국 유지보수나 확장 면에서 보다 효율적일 수 있다.

#7_ SOLID, 개방 폐쇄 원칙(OCP) : OCP(Open/Close Principle)
개방 폐쇄 원칙(Open/Close Principle)이란 소스가 기능 확장에는 열려있지만, 기능 수정에는 닫혀있어야 한다는 원칙이다. 
보다 쉽게 말해서, 새로운 기능을 추가함에 있어서는 신규 기능에 대한 소스 추가만 진행해야 하고 기존의 코드를 수정해야 하는 일은 없어야 한다는 것이다.
만약, 새로운 기능을 추가하는데에 있어서 기존의 코드를 수정해야 한다면 기존의 코드가 좋지 않게 디자인 되었다는 것으로 생각할 수 있다.
바로 예제를 통해 확인해보도록 하자. 다음의 코드는 OCP가 잘 지켜지지 못한 코드이다.

# OCP를 지키지 못한 예제
class Message:
    """Message 추상 클래스"""
    def __init__(self, data):
        self.data = data
 
class FirstGradeMessage(Message):
    """FirstGrade에 대한 메세지 처리 클래스"""
    
class SecondGradeMessage(Message):
    """SecondGrade에 대한 메세지 처리 클래스"""
    
class ThirdGradeMessage(Message):
    """ThirdGrade에 대한 메세지 처리 클래스"""
    
class DefaultGradeMessage(Message):
    """DefaultGrade에 대한 메세지 처리 클래스"""
    
class GradeMessageClassification():
    """Grade에 따른 메세지 분류 클래스"""
    def __init__(self, data):
        self.data = data
        
    def classification(self):
        if(self.data['grade'] == 1):
            return FirstGrade(self.data)
        elif(self.data['grade'] == 2):
            return SecondGrade(self.data)
        elif(self.data['grade'] == 3):
            return ThirdGrade(self.data)
        else:
            return DefaultGrade(self.data)

위의 코드는 특정 grade 별로 메세지를 다르게 처리하기 위해, 수신받은 data의 grade가 어떠한지 분류하는 기능을 담당하고 있다.
먼저 각각의 gradeMessage가 상속하고 있는 Message 클래스를 정의하고, 이후 4개의 grade별 Message클래스를 정의하였다.
마지막, GradeMessageClassification클래스는 수신받은 데이터의 grade에 따라서 올바른 class를 리턴해주고 있다.
위의 코드 또한 현 상황에서 아무런 무리없이 작동할 것이다.
하지만 새로운 요구사항에 따라서 FourthGrade가 추가되었다고 생각해보자.
우리는 FourthGradMessage를 새롭게 정의할 것이다. 이는 신규 기능에 따른 확장이므로 문제가 없다.
하지만 해당 grade를 적절히 분류하기 위해 우리는 기존에 정의되어있던 GradeMessageClassification클래스의 classification 함수에 
elif를 추가하여 fourthGrade에 대한 분류를 추가해주어야 한다.
즉 기존 로직에 대한 수정이 발생하게 되는 것이다.
이러한 상황처럼 위의 코드는 신규 기능에 대해서 소스 수정이 닫혀있지 않고 열려있게 되어 OCP에 만족하지 못한다고 볼 수 있다.
별개로, grade가 더욱 다양해진다면 위의 classification함수와 같이 if문에 의한 처리는 코드의 번잡성만 증가시킬 뿐이다.
그럼 이를 어떻게 해결할 수 있을까?
동일한 기능이지만, OCP를 만족하는 아래의 코드를 살펴보자.

# OCP가 적용된 예제
class Message:
    """Message 추상 클래스"""
    def __init__(self, data):
        self.data = data
        
    @staticmethod
    def is_collect_grade_message(data: dict):
        return False
 
class FirstGradeMessage(Message):
    """FirstGrade에 대한 메세지 처리 클래스"""
    @staticmethod
    def is_collect_grade_message(data: dict):
        return data['grade'] == 1
    
class SecondGradeMessage(Message):
    """SecondGrade에 대한 메세지 처리 클래스"""
    @staticmethod
    def is_collect_grade_message(data: dict):
        return data['grade'] == 2
    
class ThirdGradeMessage(Message):
    """ThirdGrade에 대한 메세지 처리 클래스"""
    @staticmethod
    def is_collect_grade_message(data: dict):
        return data['grade'] == 3
    
class DefaultGradeMessage(Message):
    """DefaultGrade에 대한 메세지 처리 클래스"""
    
class GradeMessageClassification():
    """Grade에 따른 메세지 분류 클래스"""
    def __init__(self, data):
        self.data = data
        
    def classification(self):
        for grade_message_cls in Message.__subclasses__():
            try:
                if grade_message_cls.is_collect_grade_message(self.data):
                    return grade_message_cls(self.data)
            except KeyError:
                continue
                
            return DefaultGradeMessage(self.data)

우선 가장 크게 변화된 점은, Message 클래스에서 is_collect_grade_message 함수가 추가되었고, 모든gradeMessage클래스에서 이를 재정의하고 있다.
이후 classification을 살펴보면, 이전의 if문과 달리, Message.__subclasses__()를 통해, Message 클래스를 상속받는 모든 클래스를 가져와, 
is_collect_grade_message 함수를 호출하여 수신받은 data의 grade를 확인한다.
이와 같이 코드를 작성하면 새롭게 FourthGrade가 추가되더라도, 아래와 같이 FourthGradeMessage 클래스만 정의해주면 될 것이다.

# OCP가 적용된 예제를 기반으로 grade 추가시에는 아래와 같이 Message 클래스를 상속받는 클래스만 생성해주면 된다.
class FourthGradeMessage(Message):
    """FourthGrade에 대한 메세지 처리 클래스"""
    @staticmethod
    def is_collect_grade_message(data: dict):
        return data['grade'] == 4

이처럼 FourthGrade라는 새로운 요구사항이 추가되어도 우리는 기존의 로직에 손대거나 수정할 필요가 없어진다.
이렇게 OCP를 지키게 되면 새로운 요구사항에 대해서 기존의 로직을 수정해야 하는일이 없게 되므로 시스템 안정성 뿐만 아니라 
유지보수 측면에서도 좋은 이점을 가져올 수 있다.

#8_ SOLID, 리스코프 치환 원칙(LSP) : LSP(Liskov Substitution Principle)
리스코프 치환 원칙은, SOLID 원칙 중에서도 많은 분들이 헷갈려하거나 어려워하는 원칙이다.
리스코프 치환 원칙에 대한 정의(LISKOV 01)는 다음과 같다.
만약 S가 T의 하위 타입이라면, 프로그램을 변경하지 않고 T타입의 객체를 S타입의 객체로 치환 가능해야 한다.
이것이 어떤 의미일까?
필자가 공부하고 있는 "파이썬 클린코드" 서적에서는 다음과 같이 이야기한다.
LSP의 주된 생각은 어떤 클래스에서든 클라이언트는 특별한 주의를 기울이지 않고도 하위 타입을 사용할 수 있어야 한다는 것이다.
다시 말해, 기반 클래스의 작업을 하위 클래스의 인스턴스로 작업할 수 있어야 한다는 것이다.
말보다는 코드로써 이해하는 것이 편할 수 있다.
먼저 리스코프 치환 원칙을 지키지 못하고 있는 첫번째 예제를 살펴보자.

# LSP를 지키지 못한 예제 1
class Event:
    """Super class: Event class"""
    def __init__(self, event_data: dict):
        this.event_data = event_data
        
    def meet_condition(self, event_data: dict) -> bool:
        return False
    
class LoginEvent(Event):
    """Sub class: LoginEvent class"""
    def meet_condition(self, event_data: list) -> bool:
        return event_data[0] == 'login'

위의 코드를 살펴보면 Event 클래스를 상속받는 LoginEvent 클래스가 있다.
하지만 재정의한 메서드, meet_condition 함수를 살펴보면 부모 클래스에서 정의한 파라미터와 다른 타입을 사용하고 있다. 
이러한 경우, Event 개체에 대해서 LoginEvent 개체로 치환시에 에러가 발생할 것이다.
이를 해소하기 위해서는 아래와 같이 변경되어야 한다.

# LSP를 적용한 예제 1
class Event:
    """Super class: Event class"""
    def __init__(self, event_data: dict):
        this.event_data = event_data
        
    def meet_condition(self, event_data: dict) -> bool:
        return False
    
class LoginEvent(Event):
    """Sub class: LoginEvent class"""
    def meet_condition(self, event_data: dict) -> bool:
        return event_data['before']["session"] == 0 and event_data['after']["session"] == 1

하지만 이 또한 문제가 있다.
보다 구체적으로 살펴보기 위해 몇가지 클래스들을 추가해서 살펴보자.

# LSP를 지키지 못한 예제 2
class Event:
    """Super class: Event class"""
    def __init__(self, event_data: dict):
        self.event_data = event_data
 
    @staticmethod
    def meets_condition(event_data: dict) -> bool:
        return False
    
    @staticmethod    
    def meets_condition_pre(event_data: dict) -> bool:
        assert isinstance(event_data, dict), f"{event_data!r} is not a dictionary."
        for data in ["before","after"]:
            assert data in event_data, f"{data} is not in {event_data}."
    
class LoginEvent(Event):
    """Sub class: LoginEvent class"""
    @staticmethod
    def meets_condition(event_data: dict) -> bool:
#         assert "session" in event_data["before"] and "session" in event_data["after"]
        return event_data['before']["session"] == 0 and event_data['after']["session"] == 1
         
class UnknownEvent(Event):
    def meet_condition(self, event_data: dict) -> bool:
        return True
    
class SystemMonitor:
    def __init__(self, event_data):
        self.event_data = event_data
        
    def identify_event(self):
        Event.meets_condition_pre(self.event_data)
        event_cls = next(
            (event_cls for event_cls in Event.__subclasses__() if event_cls.meets_condition(self.event_data)),
            UnknownEvent
        )
        return event_cls(self.event_data)

이전의 코드에 UnknownEvent를 추가하고 입력받은 event_data가 어떠한 것인지 구별하는 SystemMonitor 클래스를 추가하였다.
여기서, LoginEvent 클래스의 meets_condition 함수에 추가된 주석을 신경쓰길 바란다. 
해당 함수의 리턴값을 살펴보면 실제로 주석처리된 assert가 통과해야 함을 알 수 있다.
우선 이상태로 해당 코드를 실행시켜보면 다음과 같은 결과를 얻을 수 있다.

l1 = SystemMonitor({"before":{"session":0}, "after":{"session":1}})
print(f"l1 is {l1.identify_event().__class__.__name__!r}")
 
l2 = SystemMonitor({"before":{"session":1}, "after":{"session":0}})
print(f"l2 is {l2.identify_event().__class__.__name__!r}")
 
l3 = SystemMonitor({"before":{}, "after":{"session":0}})
print(f"l3 is {l3.identify_event().__class__.__name__!r}")
 
l1 is 'LoginEvent'
l2 is 'UnknownEvent'
---------------------------------------------------------------------------
KeyError                                  Traceback (most recent call last)
<ipython-input-29-889278fd8833> in <module>()
      6 
      7 l3 = SystemMonitor({"before":{}, "after":{"session":0}})
----> 8 print(f"l3 is {l3.identify_event().__class__.__name__!r}")
 
<ipython-input-28-0ef7b0926e45> in identify_event(self)
     35         event_cls = next(
     36             (event_cls for event_cls in Event.__subclasses__() if event_cls.meets_condition(self.event_data)),
---> 37             UnknownEvent
     38         )
     39         return event_cls(self.event_data)
 
<ipython-input-28-0ef7b0926e45> in <genexpr>(.0)
     34         Event.meets_condition_pre(self.event_data)
     35         event_cls = next(
---> 36             (event_cls for event_cls in Event.__subclasses__() if event_cls.meets_condition(self.event_data)),
     37             UnknownEvent
     38         )
 
<ipython-input-28-0ef7b0926e45> in meets_condition(event_data)
     20     def meets_condition(event_data: dict) -> bool:
     21 #         assert "session" in event_data["before"] and "session" in event_data["after"]
---> 22         return event_data['before']["session"] == 0 and event_data['after']["session"] == 1
     23 
     24 
 
KeyError: 'session'

앞에서 걱정한 바와 같이, 실제로 데이터에 "session"이 존재하지 않는 l3 에서 KeyError가 발생한 것을 확인할 수 있다. 
이러한 경우 처음 살펴보았던 예제와 마찬가지로, Event 개체가 LoginEvent 개체로 치환될 경우 에러가 발생할 수 있다.
이러한 케이스가 발생하지 않기 위해, 하위 클래스가 따라야하는 계약 조건이 있다.
1. 하위 클래스는 부모 클래스에 정의된 것보다 사전조건을 엄격하게 만들면 안 된다.
2. 하위 클래스는 부모 클래스에 정의된 것보다 약한 사후조건을 만들면 안된다.
방금 살펴본 예제는 위의 조건 중 1번에 대해 위반을 한 것이다. 비록 주석처리를 해두었지만, 
하위클래스(LoginEvnet class)가 에러없이 실행되려면 데이터에 "session"이 존재해야 함을 기반으로 한다. 
하지만 이러한 사전조건은 부모클래스(Event class)보다 엄격한 것이므로, 살펴본 것과 같이 에러가 발생할 수 있는 것이다.
이러한 코드에 대해 LSP 원칙을 적용하면 다음과 같이 .get() 함수를 이용하여 변경 가능하다.

# LSP를 적용한 예제 2
class Event:
    """Super class: Event class"""
    def __init__(self, event_data: dict):
        self.event_data = event_data
 
    @staticmethod
    def meets_condition(event_data: dict) -> bool:
        return False
    
    @staticmethod    
    def meets_condition_pre(event_data: dict) -> bool:
        assert isinstance(event_data, dict), f"{event_data!r} is not a dictionary."
        for data in ["before","after"]:
            assert data in event_data, f"{data} is not in {event_data}."
    
class LoginEvent(Event):
    """Sub class: LoginEvent class"""
    @staticmethod
    def meets_condition(event_data: dict) -> bool:
        return event_data['before'].get("session") == 0 and event_data['after'].get("session") == 1
        
class UnknownEvent(Event):
    def meet_condition(self, event_data: dict) -> bool:
        return True
    
class SystemMonitor:
    def __init__(self, event_data):
        self.event_data = event_data
        
    def identify_event(self):
        Event.meets_condition_pre(self.event_data)
        event_cls = next(
            (event_cls for event_cls in Event.__subclasses__() if event_cls.meets_condition(self.event_data)),
            UnknownEvent
        )
        return event_cls(self.event_data)

그리고 해당 코드에 대한 실행 결과는 다음과 같다.

l1 = SystemMonitor({"before":{"session":0}, "after":{"session":1}})
print(f"l1 is {l1.identify_event().__class__.__name__!r}")
 
l2 = SystemMonitor({"before":{"session":1}, "after":{"session":0}})
print(f"l2 is {l2.identify_event().__class__.__name__!r}")
 
l3 = SystemMonitor({"before":{}, "after":{"session":0}})
print(f"l3 is {l3.identify_event().__class__.__name__!r}")
 
l1 is 'LoginEvent'
l2 is 'UnknownEvent'
l3 is 'UnknownEvent'

리스코프 치환 원칙은, 한번에 이해하거나 바로 받아들이기 어려울 수 있다.
필자가 책을 참고하여 언급한 예제 이외에도 검색을 통해 다양한 예제와 설명을 만나볼 수 있으니 함께 참고하면서 공부하기를 바란다.
무엇보다, 리스코프 치환 원칙은 부모클래스 타입과 하위클래스 타입, 두가지 타입의 개체를 서로 치환하더라도 
에러가 발생하는 등의 문제가 발생하면 안된다는 것을 기억하기를 바란다.

#9_ SOLID, 인터페이스 분리 원칙(ISP) : ISP(Interface Segregation Principle)
인터페이스 분리 원칙(ISP)은, 클라이언트가 자신이 이용하지 않는 메소드에 의존하면 안된다라는 원칙이다.
다른 방향으로 해석해보자면, 하나의 인터페이스는그 책임에 맞는 메소드만 가지고 있어야 한다는 의미이다. 
책임이라는 용어, 매우 익숙할 것이라고 생각한다.
SOLID에 대해서 알아보며 첫번째로 다루었던 SRP원칙과 매우 유사하게 느껴질 것이다. 
물론 SOLID 원칙 모두가 상호 연관 관계가 있고, 좋은 코드를 목표로 하고 있기 때문에 더욱 그렇게 느껴질 수 있다.
이번에 다뤄볼 ISP와 이전에 학습한 SRP의 차이점을 생각해본다면, ISP는 보다 직접적으로 인터페이스에 대해서 이야기하고 있는 것이다. 
인터페이스가 다양한 책임을 가지고 있거나, 자신의 책임과 걸맞지 않는 메서드를 가지고 있게되면, 
해당 인터페이스를 구현하는 클래스 모두에게 영향을 미치게 된다.

# ISP를 지키지 못한 예제
from abc import *
 
class EventParser(metaclass=ABCMeta):
    """Interface: EventParser class"""
    @abstractmethod
    def from_json(self, event_data):
        pass
    
    @abstractmethod
    def from_xml(self, event_data):
        pass    

위 코드에서 사용한 abc라이브러리를 통해 EventParser 인터페이스를 구현하였다.
EventParser 내부에 정의된 2개의 추상메서드를 살펴보자. fron_json()과 from_xml()이 모두 정의되어있다. 
그렇다면 해당 EventParser를 구현하는 클래스는 json, xml 필요한 것만 구현하는 것이 아니라, 
처리하는 데이터와 무관하게 두가지 함수를 모두 구현해야 한다.
즉, 자신이 이용하지 않는 메서드에 의존하게 되는 것이다.
이러한 것이 ISP원칙을 위반한 사례라고 볼 수 있다.
이를 해결하려면 어떻게 할까? 간단하게 생각해서, 그 책임을 분할시켜주면 된다.

# ISP를 적용한 예제
from abc import *
 
class JsonEventParser(metaclass=ABCMeta):
    """Interface: JsonEventParser class"""
    @abstractmethod
    def from_json(self, event_data):
        pass    
    
class XmlEventParser(metaclass=ABCMeta):
    """Interface: XmlEventParser class"""
    @abstractmethod
    def from_xml(self, event_data):
        pass    

위의 코드는 기존의 EventParser를 분리하여 JsonEventParser와 XmlEventParser로 분리하였다. 
이렇게 인터페이스를 분리함에 따라서, 인터페이스를 구현하는 클래스가 자신이 이용하지 않는 메서드에 의존하게 되는 문제를 해결한 것이다.
하지만, 위와 같이 고려하다보면 "하나의 인터페이스는 하나의 메서드만 가져야하는 것일까?" 라는 생각에 부딪힐 수 있다. 
물론 그렇지 않다.
앞에서의 예제들은 설명을 위해 간략하게 작성한 예제라서 그렇지만, 결국 말하고자 하는 것은 하나의 인터페이스에서 하나의 일만 해야한다는 것이다.
하나의 메서드만 있어야 한다는 것이 아니라, 하나의 일을 담당해야 한다는 것은 동일한 맥락의 책임이라면 
이를 처리하기 위해 여러개의 메서드가 존재할 수 있다는 것이다.
예를 들어, XmlEventParser 클래스에서 비즈니스 로직과, 데이터 검토 결과 동일한 데이터 전처리가 필요하다고 판단되면 해당 메서드를 추가할 수 있는 것이다.
이는 ISP 뿐만 아니라 모든 SOLID원칙에도 적용된다. 
SOLID 원칙은 기본적인 것을 이야기 할 뿐이지, SOLID 원칙에서 언급되는 예제에 대해서는 
실제 업무와 환경, 비즈니스 로직, 다양한 변수들에 의해 조금씩은 다르게 구현될 수 있다.


#10_ SOLID, 의존성 역전 원칙(DIP) : DIP(Dependency Inversion Principle)
우선 의존성 역전 원칙(DIP)의 정의에 대해서 알아보자.
의존성 역전 원칙은, 추상화를 통해 세부 사항에 의존하지 않도록 해야 하지만, 반대로 세부 사항(구체적인 구현)은 추상화에 의존해야 한다는 원칙이다.
쉽게 말해서, 보다 고수준 모듈(클래스)은 보다 저수준 모듈(클래스)에 대해 의존하면 안된다는 것이고, 
의존하지 않는다는 것은 저수준 모듈의 변경이나 추가 등에 있어서 변경점이 없어야 한다는 것이다.
파이썬이라는 언어의 특성상 융통성이 있으며, 동적 언어이기 때문에 예제들을 살펴볼때 이것이 왜 필요한지 의문이 들 수 있다. 
이에 대해 본인이 참고하고 있는 "파이썬 클린코드"의 저자는 다음과 같이 이야기한다.
실제로 꼭 이렇게 할 필요는 없으며 프로그램은 똑같이 동작한다.
그러나 클린 디자인을 위해서 바람직하다. 이것이 이 책이 있는 이유 중 하나로 단지 파이썬이 너무 유연하여 자주 발생하는 실수를 줄이기 위함이다.

- 파이썬 클린코드
본인은 예제에서 assert를 이용해 조금 더 강제성을 부여하였다.
실제로 예제코드와 같은 상황은 드물겠지만, DIP를 조금 더 잘 느끼기 위함으로 이해해주기를 바란다.

# DIP를 지키지 못한 예제
from abc import *
 
class EventStreamer():
    def __init__(self, parsed_data: str, client: Syslog):
        self.parsed_data = parsed_data
        assert client is Syslog, "Client is not Syslog"
        self.client = client
        
    def stream(self):
        self.client.send(self.parsed_data)    
        
class Syslog():
    def send(data: str):
        print(f"Syslog send: {data}")
        pass
    
class OtherClient():
    def send(data: str):
        print(f"OtherClient send: {data}")
        pass
 
 
streamer1 = EventStreamer("for Syslog data!", Syslog)
streamer1.stream()
streamer2 = EventStreamer("for OtherClient data!", OtherClient)
streamer2.stream()

위의 예제를 살펴보면, EventStreamer() 라는 고수준의 모듈이 직접 Syslog를 참조함으로써, Syslog에 대해 의존하고 있다.
위의 코드를 실행시켜보면 assert에 다음과 같이 에러가 발생한다.

Syslog send: for Syslog data!
---------------------------------------------------------------------------
AssertionError                            Traceback (most recent call last)
<ipython-input-46-d6c168be4001> in <module>()
     24 streamer1 = EventStreamer("for Syslog data!", Syslog)
     25 streamer1.stream()
---> 26 streamer2 = EventStreamer("for OtherClient data!", OtherClient)
     27 streamer2.stream()
 
<ipython-input-46-d6c168be4001> in __init__(self, parsed_data, client)
      5     def __init__(self, parsed_data: str, client: Syslog):
      6         self.parsed_data = parsed_data
----> 7         assert client is Syslog, "Client is not Syslog"
      8         self.client = client
      9 
 
AssertionError: Client is not Syslog

물론 위의 에러는 본인이 assert를 통해 강제성을 부여하였기에 발생된 에러지만, 
실제로 Java와 같은 정적 언어에서는 타입이 지정되기 때문에 에러가 발생할 것이다.
또한 예제이기 때문에 각 함수들에 대해 구체적인 행동을 만들어주지 않았지만, 
만약 Syslog의 send() 함수가 변경되었을 때에는 EventStreamer 클래스도 변경해야 할 가능성이 생긴다.
위와 같은 상황에서 Syslog 클래스와 OtherClient 클래스를 추상화하는 DataTargerClient 인터페이스를 만들어 줌으로써 DIP를 만족시킬 수 있다.

# DIP를 적용한 예제
from abc import *
 
class EventStreamer():
    def __init__(self, parsed_data: str, client):
        self.parsed_data = parsed_data
        assert client in DataTargetClient.__subclasses__(), "Client is not DataTargetClient"
        self.client = client
        
    def stream(self):
        self.client.send(self.parsed_data)
 
class DataTargetClient(metaclass=ABCMeta):
    """Interface: DataTargetClient class"""
    @abstractmethod
    def send(self, data: str):
        pass            
        
class Syslog(DataTargetClient):
    def send(data: str):
        print(f"Syslog send: {data}")
        pass
    
class OtherClient(DataTargetClient):
    def send(data: str):
        print(f"OtherClient send: {data}")
        pass
 
 
streamer1 = EventStreamer("for Syslog data!", Syslog)
streamer1.stream()
streamer2 = EventStreamer("for OtherClient data!", OtherClient)
streamer2.stream()

위와 같이 기존의 Syslog 클래스와 OtherClient 클래스가 DataTargetClient를 구현하고 있으며, 
EventStreamer 클래스는 단지 DataTargetClient 인터페이스와 관계를 가질뿐, 실제 구체적인 구현과는 의존성이 사라지게 된다.


'''